AIチャットアプリケーション開発仕様書 

==================================================

1. 要求定義 (ユーザー要求)

1.1. プロジェクトゴール
最新の生成AIモデルを活用し、テキストだけでなく画像やファイルも扱える、高機能で直感的なチャットアプリケーションを開発する。これにより、ユーザーは情報収集、学習、プログラミング、アイデア創出など、多様な知的作業を効率的に行えるようになることを目指す。

1.2. ユーザーストーリー

開発者として、プログラミングに関する質問をし、コードスニペットを含んだ回答をシンタックスハイライト付きで受け取りたい。
研究者として、複雑な数式を含む論文の要約を依頼し、数式が正しくレンダリングされた状態で読みたい。
デザイナーとして、簡単なアイコンや図の作成をAIに指示し、SVG形式のベクター画像として即座に受け取りたい。
一般的なユーザーとして、画像やテキストファイルをAIに見せて、その内容について質問したい。
すべてのユーザーとして、過去のチャット履歴を簡単に保存し、後から読み込んで対話を再開したい。

2. 要件定義 (システム要件)

2.1. 機能要件
システムが提供すべき具体的な機能。

・設定管理
ユーザーは、使用するAIモデル名とAPIキーを設定できる。
設定内容はURLパラメータとして永続化できる。

・チャット機能
ユーザーはテキストメッセージを送信できる。
ユーザーは画像ファイル（image/*）を添付して送信できる。
ユーザーはテキストベースのファイル（.txt, .js等）を添付して送信できる。
ユーザーはテキストとファイルを同時に送信できる。
ユーザーはメッセージ入力エリアへのドラッグ＆ドロップでファイルを添付できる。
ユーザーはメッセージ送信前に、添付ファイルの一覧を確認できるプレビューエリアを持つ。各ファイルには添付を取り消すためのキャンセルボタン（「×」ボタンなど）を設ける。

・コンテンツ表示機能
メッセージはMarkdownとして解釈され、見出し、リスト、引用などが適切に表示される。
メッセージ内のLaTeX形式の数式（$...$, $$...$$）は、数式としてレンダリングされる。
メッセージ内のSVGコードブロックは、レンダリングされた画像として表示される。
上記以外のコードブロックは、言語に応じてシンタックスハイライトが適用される。

・チャット履歴管理機能
ユーザーは、現在のチャット履歴（全メッセージ、タイムスタンプ、添付ファイル）をJSONファイルとしてダウンロードできる。
ファイル名は chat-history-MMDD-HHmm.json の形式とする。ここで、MMは月（2桁）、DDは日（2桁）、HHは時（24時間表記・2桁）、mmは分（2桁）とする。
ユーザーは、ダウンロードしたJSONファイルをアップロードし、チャット履歴を完全に復元できる。
履歴の復元時は、ユーザーとAI双方の全メッセージ（添付ファイル情報を含む）に対して、後述のコンテンツレンダリングパイプライン（Markdown、数式、コードハイライト等）を適用し、表示を完全に再現すること。

2.2. 非機能要件

・ユーザーエクスペリエンス (UX)
チャットUIは、ユーザーとAIのメッセージが左右に分かれる吹き出し形式であること。
メッセージのコピーと時刻表示: 各メッセージ吹き出しの横に、コピーボタンと送信時刻(HH:MM形式)を常に表示する。要素はコピーボタンを上に、時刻を下に縦に並べる。
AIの応答中は、タイピング中であることが視覚的にわかるインジケーターを表示すること。
AIの応答完了時に、控えめな通知音を再生すること。
操作のフィードバック: コードやSVG、メッセージ本文を簡単にコピーできるボタンを提供し、操作成功時には「コピーしました！」のようなメッセージを画面に短時間表示する（トースト通知）。
コンテンツ操作:
  - コードやSVGは、ブロックごとにコピーボタンとダウンロードボタンを提供すること。
  - 数式は、マウスホバーした際にのみ、その数式のLaTeXコードをコピーするためのボタンを表示すること。このボタンは、数式コンテナの表示領域をはみ出さないよう、コンテナの内側の右上隅に配置する。
  - コンテンツの高さ制限: コードブロックやSVGブロックが縦に長くなりすぎ、チャット全体の可読性を損なうことを防ぐため、これらのブロックには適切な高さの上限（例：400px）を設定し、内容がはみ出す場合はブロック内で垂直スクロールできるようにすること。
入力エリアと操作: メッセージ入力欄は、入力内容に応じて高さが自動で調整されること。Ctrl+Enter (MacではCmd+Enter) でメッセージを送信できること。
スクロール動作:
  - メッセージ追加時: ユーザーまたはAIのメッセージがDOMに追加された直後、チャット履歴が常に最下部にスクロールされること。
  - AI応答完了時: AIからのストリーミング応答がすべて完了した時点で、そのAIメッセージの最上部が表示領域の上端に揃うようにスクロールすること。
  - 手動スクロールによる抑制: 上記1, 2の自動スクロールは、ユーザーが手動でスクロール中は実行されないこと。具体的には、スクロール位置が最下部から一定量（例: 100px）以上離れている状態を「手動スクロール中」と判定する。
  - 自動スクロールの再開: ユーザーが新たにメッセージを送信した時点で、手動スクロール状態を解除し、自動スクロールを再度有効にすること。

・パフォーマンス
AIからの応答は、ユーザーの待ち時間を減らすため、ストリーミングで逐次表示すること。（具体的な表示方式は技術仕様で定義）
ファイルの読み込みやAPI通信は非同期で行い、UIのブロッキングを避けること。

・セキュリティ
APIキー入力欄は、入力内容が見えないようにパスワード形式 (type="password") にすること。

・エラーハンドリング
APIキーが未設定、または無効な場合は、チャット機能を無効化し、設定を促すこと。具体的には、メッセージ入力欄、送信ボタン、ファイル添付ボタン、および履歴管理機能（ダウンロード、アップロード）を操作不能状態にする。
API通信でエラーが発生した場合、エラーメッセージをユーザーがコピー可能な形式で画面に表示し、入力内容（テキストや添付ファイル）を保持したまま再送信できるようにすること。
実装上の注意：この要件を満たすため、API呼び出しが成功した場合にのみ入力エリアのテキストと添付ファイルをクリアする、という処理順序を徹底すること。

3. 技術仕様

3.1. 開発環境・技術スタック

基本構成: すべてのコードを単一のHTMLファイルに記述する。
言語: HTML, CSS, Vanilla JavaScript (ES Modules形式)
外部ライブラリ (ES Modules形式でCDNから読み込む):
  - @google/generative-ai: Google Gemini APIとの通信用
  - marked: Markdownレンダリング用
  - highlight.js: コードブロックのシンタックスハイライト用
  - highlight.jsのテーマCSS: シンタックスハイライトを適用するため、<head>内でテーマCSS（例: a11y-dark.min.css）をCDNから読み込むこと。
  - MathJax: 数式レンダリング用
UI実装上の注意点:
  - 設定フォームの「適用」ボタンは type="submit" で実装し、フォーム送信によって設定を適用する。
  - フォーム内の他のボタン（例：履歴ダウンロード）は、フォーム送信を引き起こさないよう type="button" とする。

3.2. API連携仕様 (Google Gemini API)

初期化:
GoogleGenerativeAI(apiKey)でクライアントを初期化する。
getGenerativeModel()でモデルを取得する際、以下のsystemInstructionを必ず設定する。
「ユーザーから図形やグラフの描画を指示された場合は、必ずSVGコードを生成し、そのコードブロックの言語指定を ```svg として応答してください。他の形式（xmlなど）は使用しないでください。また、数式を記述する際は、必ずLaTeX形式（インラインは$...$、ブロックは$$...$$）を使用してください。」

メッセージ送信:
  - 画像ファイルは、FileReader.readAsDataURL()でBase64にエンコードし、MIMEタイプを分離してinlineData形式のオブジェクト ({ inlineData: { data: "...", mimeType: "..." } }) として送信する。
  - テキストファイルは、FileReader.readAsText()で内容を読み込み、以下の形式のプロンプトに整形して送信する。
    [添付ファイル: {ファイル名}]\n```\n{ファイルの内容}\n```
  - 履歴の整形: APIに渡す履歴配列（history）を生成する際、過去のユーザーメッセージにファイルが添付されていた場合は、AIが文脈を理解しやすくするため、[ユーザーは過去のターンでファイル「{ファイル名}」を添付しました] のようなテキストをtextパートの先頭に追加すること。

3.3. コンテンツレンダリング仕様

・AI応答の表示方式: AIからの応答はストリーミングで受信するが、レンダリング負荷と表示の安定性を考慮し、応答が完了するまではプレーンテキストとして表示する。応答完了後、後述のレンダリングパイプラインを一度に実行し、リッチコンテンツ（Markdown、数式、コードブロック等）に変換する。

・レンダリングパイプライン（処理順序）:
1. Markdown変換: marked.parse()でメッセージ文字列をHTMLに変換する。
2. HTMLをDOMに追加: 生成されたHTMLをメッセージバブルのコンテナにinnerHTMLで設定する。
3. SVGとコードの処理: コンテナ内の`<pre><code>`要素を探索し、言語指定に応じてSVG描画またはhighlight.jsによるハイライト処理を行う。
4. 数式処理: DOMにコンテンツが追加された直後、ブラウザがレイアウト計算を完了する前にMathJaxを実行すると、コンテナの寸法を正しく取得できずコンソールエラー（例: Error: <svg> attribute width: Expected length, "NaNex".）が発生する。これを避けるため、setTimeout(..., 0) を用いて処理を遅延させ、レイアウト計算が完了した後にコンテナ全体に対して MathJax.typesetPromise() を実行する。

・数式レンダリング (MathJax):
コンテナ全体に対して MathJax.typesetPromise() を実行し、数式をレンダリングする。
  - コピーボタンの実装方針:
    処理1: AIからの応答テキストを受け取った時点で、メッセージ本文から正規表現を用いて、すべてのLaTeX形式の数式文字列（例：ドル記号1つで囲まれたインライン数式や、ドル記号2つで囲まれたブロック数式）を抽出し、配列として保持する。
    処理2: MathJax.typesetPromise() の完了後、コンテナ内からレンダリング済みの数式要素（mjx-container要素）をすべて取得する。
    処理3: 取得した数式要素の配列と、事前に抽出したLaTeX文字列の配列を、出現順に紐付ける。
    処理4: 各数式要素にマウスホバーイベントを設定し、ホバー時にコピーボタンを動的に表示する。ボタンには、対応するLaTeX文字列をコピーする機能を割り当てる。
  - 実装上の注意:
    この方式は、MathJaxライブラリの内部実装（例: 属性の有無）に依存しないため、将来のアップデート耐性が高い。
    MathJax.typesetPromise() の完了直後にDOM操作を行うと、ブラウザの描画が間に合わない場合がある。完了後の処理は setTimeout(..., 0) を用いて次の描画サイクルで実行すること。
  - オーバーフロー対策: レンダリングされた数式（特に長いインライン数式）がメッセージの幅を超えて表示が崩れるのを防ぐこと。MathJaxが生成するコンテナ要素（mjx-container）に対して max-width: 100%; と overflow-x: auto; を適用し、はみ出した部分は水平スクロールで閲覧できるようにする。
  - コピーボタンの配置: ホバー時に表示するコピーボタンは、親コンテナ（mjx-container）の内側に配置すること。position: absolute; を使用し、top と right プロパティで右上隅からのオフセット（例: top: 2px; right: 2px;）を指定する。transform: translate(...) を用いてコンテナの外側に配置する手法は、意図しないレイアウト崩れやスクロールバーの発生原因となるため避けること。

・SVGレンダリング:
  - svg言語が指定されたコードブロックを、レンダリングされた画像として表示する。
  - 表示されたSVGラッパーには、タイトル（"SVG"）、コピーボタン、ダウンロードボタンを含むヘッダーを設ける。
  - ダウンロードするファイル名は fig-MMDD-HHmm.svg のように、月日と時分を付与する。

・コードブロックレンダリング (highlight.js):
  - svg以外の言語が指定されたコードブロックにhighlight.jsを適用する。
  - 各コードブロックには、言語名、コピーボタン、ダウンロードボタンを含むヘッダーを設ける。
  - DOM実装上の注意:
    markedライブラリが生成したpreタグとcodeタグの組を、自作のヘッダー付きコンテナで「包み込む(wrap)」方式で実装すること。生成された要素を直接 replaceWith() で置き換えようとすると、DOMの循環参照エラーが発生する可能性があるため注意する。
  - CSS実装上の注意:
    highlight.jsのテーマが適用されると、preタグ自体に背景色とpaddingが設定される。自作コンテナのスタイルと重複して二重枠に見えるのを防ぐため、コンテナの背景色はテーマの背景色に合わせ、preタグ自体の背景色は transparent に、paddingは0に上書きすること。
  - ダウンロードするファイル名は code-MMDD-HHmm.[拡張子] のように、月日と時分を付与する。拡張子は言語名から推測される標準的なもの（例: javascript -> .js）を使用する。
  - CSSで white-space: pre-wrap; word-break: break-all; を指定し、長い行の強制折り返しを行う。
  - レスポンシブ対応: 幅の狭い画面でボタンのテキストが縦書きになることを防ぐため、button要素には white-space: nowrap; と flex-shrink: 0; を適用すること。

・通知音の再生:
  - 実装方針: ブラウザの自動再生ポリシー（ユーザーの操作なしに音声を再生できない制約）を回避するため、AudioContext Web API を用いて動的に音を生成する方式を採用する。音声ファイルの読み込みは行わない。
  - 処理フロー:
    1. AudioContextのインスタンスは、ページ読み込み時ではなく、ユーザーが初めてメッセージを送信するイベントハンドラ内で生成し、resume()を呼び出して有効化する。これにより、ユーザー操作と音声再生機能の有効化が紐付けられる。
    2. AIの応答完了時に再生する通知音は、AudioContextのcreateOscillator（発振器）とcreateGain（音量制御）を用いて生成する。
    3. 音の仕様は、耳障りでない440Hz〜880Hz程度の正弦波（sine）を、約0.2秒程度の短いフェードアウトで再生するものとする。

3.4. 履歴データ構造 (JSON)
チャット履歴は、メッセージオブジェクトの配列として表現する。ユーザーメッセージには、添付ファイル情報を保持するための files 配列をオプションとして含めることができる。
files 配列の各要素は、ファイル名(name)、MIMEタイプ(type)、およびBase64エンコードされたコンテンツまたはプレーンテキストコンテンツ(content)を含むオブジェクトとする。

[
  {
    "role": "user",
    "text": "この画像について説明してください。",
    "timestamp": "2023-10-28T10:00:05.123Z",
    "files": [
      {
        "name": "cat-on-a-laptop.jpg",
        "type": "image/jpeg",
        "content": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD..."
      }
    ]
  },
  {
    "role": "ai",
    "text": "はい、これはラップトップキーボードの上でくつろいでいる猫の画像です。",
    "timestamp": "2023-10-28T10:00:10.456Z"
  },
  {
    "role": "user",
    "text": "二次方程式 $ax^2 + bx + c = 0$ の解の公式を教えてください。",
    "timestamp": "2023-10-28T10:01:15.987Z"
  },
  {
    "role": "ai",
    "text": "はい、二次方程式の解の公式は以下の通りです。\n\n$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}$$\n",
    "timestamp": "2023-10-28T10:01:20.789Z"
  }
]
