AIチャットアプリケーション開発仕様書 

==================================================

1. 要求定義 (ユーザー要求)

1.1. プロジェクトゴール
最新の生成AIモデルを活用し、テキストだけでなく画像やファイルも扱える、高機能で直感的なチャットアプリケーションを開発する。これにより、ユーザーは情報収集、学習、プログラミング、アイデア創出など、多様な知的作業を効率的に行えるようになることを目指す。

1.2. ユーザーストーリー

開発者として、プログラミングに関する質問をし、コードスニペットを含んだ回答をシンタックスハイライト付きで受け取りたい。
研究者として、複雑な数式を含む論文の要約を依頼し、数式が正しくレンダリングされた状態で読みたい。
デザイナーとして、簡単なアイコンや図の作成をAIに指示し、SVG形式のベクター画像として即座に受け取りたい。
一般的なユーザーとして、画像やテキストファイルをAIに見せて、その内容について質問したい。
すべてのユーザーとして、過去のチャット履歴を簡単に保存し、後から読み込んで対話を再開したい。

2. 要件定義 (システム要件)

2.1. 機能要件
システムが提供すべき具体的な機能。

・設定管理
ユーザーは、使用するAIモデル名とAPIキーを設定できる。
設定内容はURLパラメータとして永続化できる。

・チャット機能
ユーザーはテキストメッセージを送信できる。
ユーザーは画像ファイル（image/*）を添付して送信できる。
ユーザーはテキストベースのファイル（.txt, .js等）を添付して送信できる。
ユーザーはテキストとファイルを同時に送信できる。
ユーザーはメッセージ入力エリアへのドラッグ＆ドロップでファイルを添付できる。
ユーザーはメッセージ送信前に、添付ファイルの一覧を確認できるプレビューエリアを持つ。各ファイルには添付を取り消すためのキャンセルボタン（「×」ボタンなど）を設ける。

・コンテンツ表示機能
メッセージはMarkdownとして解釈され、見出し、リスト、引用などが適切に表示される。
メッセージ内のLaTeX形式の数式（$...$, $$...$$）は、数式としてレンダリングされる。
メッセージ内のSVGコードブロックは、レンダリングされた画像として表示される。
上記以外のコードブロックは、言語に応じてシンタックスハイライトが適用される。

・チャット履歴管理機能
ユーザーは、現在のチャット履歴（全メッセージとタイムスタンプ）をJSONファイルとしてダウンロードできる。
ユーザーは、ダウンロードしたJSONファイルをアップロードし、チャット履歴を完全に復元できる。

2.2. 非機能要件

・ユーザーエクスペリエンス (UX)
チャットUIは、ユーザーとAIのメッセージが左右に分かれる吹き出し形式であること。
メッセージのコピーと時刻表示: 各メッセージ吹き出しの横に、コピーボタンと送信時刻(HH:mm形式)を常に表示する。要素はコピーボタンを上に、時刻を下に縦に並べる。
AIの応答中は、タイピング中であることが視覚的にわかるインジケーターを表示すること。
AIの応答完了時に、控えめな通知音を再生すること。
操作のフィードバック: コードやSVG、メッセージ本文を簡単にコピーできるボタンを提供し、操作成功時には「コピーしました！」のようなメッセージを画面に短時間表示する（トースト通知）。
コンテンツ操作: コードやSVGは、ブロックごとにコピーボタンとダウンロードボタンを提供すること。数式は、マウスホバーした際にのみ、その数式のLaTeXコードをコピーするためのボタンを表示すること。
入力エリアと操作: メッセージ入力欄は、入力内容に応じて高さが自動で調整されること。Ctrl+Enter (MacではCmd+Enter) でメッセージを送信できること。
スクロール動作: チャット履歴に新しいメッセージが追加された際、自動で最下部までスクロールすること。ただし、ユーザーが手動でスクロール中は、この動作を一時的に抑制し、ユーザーが新たにメッセージを送信した際に自動スクロールを再開すること。

・パフォーマンス
AIからの応答は、ユーザーの待ち時間を減らすため、ストリーミングで逐次表示すること。（具体的な表示方式は技術仕様で定義）
ファイルの読み込みやAPI通信は非同期で行い、UIのブロッキングを避けること。

・セキュリティ
APIキー入力欄は、入力内容が見えないようにパスワード形式 (type="password") にすること。

・エラーハンドリング
APIキーが未設定、または無効な場合は、チャット機能を無効化し、設定を促すこと。具体的には、メッセージ入力欄、送信ボタン、ファイル添付ボタン、および履歴管理機能（ダウンロード、アップロード）を操作不能状態にする。
API通信でエラーが発生した場合、エラーメッセージをユーザーがコピー可能な形式で画面に表示し、入力内容（テキストや添付ファイル）を保持したまま再送信できるようにすること。

3. 技術仕様

3.1. 開発環境・技術スタック

基本構成: すべてのコードを単一のHTMLファイルに記述する。
言語: HTML, CSS, Vanilla JavaScript (ES Modules形式)
外部ライブラリ (ES Modules形式でCDNから読み込む):
@google/generative-ai: Google Gemini APIとの通信用
marked: Markdownレンダリング用
highlight.js: コードブロックのシンタックスハイライト用
MathJax: 数式レンダリング用
UI実装上の注意点:
設定フォームの「適用」ボタンは type="submit" で実装し、フォーム送信によって設定を適用する。フォーム内の他のボタン（例：履歴ダウンロード）は、フォーム送信を引き起こさないよう type="button" とする。

3.2. API連携仕様 (Google Gemini API)

初期化:
GoogleGenerativeAI(apiKey)でクライアントを初期化する。
getGenerativeModel()でモデルを取得する際、以下のsystemInstructionを必ず設定する。
「ユーザーから図形やグラフの描画を指示された場合は、必ずSVGコードを生成し、そのコードブロックの言語指定を ```svg として応答してください。他の形式（xmlなど）は使用しないでください。また、数式を記述する際は、必ずLaTeX形式（インラインは$...$、ブロックは$$...$$）を使用してください。」

メッセージ送信:
画像ファイルは、FileReader.readAsDataURL()でBase64にエンコードし、MIMEタイプを分離してinlineData形式のオブジェクト ({ inlineData: { data: "...", mimeType: "..." } }) として送信する。
テキストファイルは、FileReader.readAsText()で内容を読み込み、以下の形式のプロンプトに整形して送信する。
[添付ファイル: {ファイル名}]\n```\n{ファイルの内容}\n```

3.3. コンテンツレンダリング仕様

・AI応答の表示方式: AIからの応答はストリーミングで受信するが、レンダリング負荷と表示の安定性を考慮し、応答が完了するまではプレーンテキストとして表示する。応答完了後、後述のレンダリングパイプラインを一度に実行し、リッチコンテンツ（Markdown、数式、コードブロック等）に変換する。

・レンダリングパイプライン（処理順序）:
1. Markdown変換: marked.parse()でメッセージ文字列をHTMLに変換する。
2. HTMLをDOMに追加: 生成されたHTMLをメッセージバブルのコンテナにinnerHTMLで設定する。
3. SVGとコードの処理: コンテナ内の`<pre><code>`要素を探索し、言語指定に応じてSVG描画またはhighlight.jsによるハイライト処理を行う。
4. 数式処理: 最後にコンテナ全体に対して MathJax.typesetPromise() を実行し、数式をレンダリングする。

・数式レンダリング (MathJax):
コンテナ全体に対して MathJax.typesetPromise() を実行し、数式をレンダリングする。
  - コピーボタンの実装方針:
    処理1: AIからの応答テキストを受け取った時点で、メッセージ本文から正規表現を用いて、すべてのLaTeX形式の数式文字列（例：ドル記号1つで囲まれたインライン数式や、ドル記号2つで囲まれたブロック数式）を抽出し、配列として保持する。
    処理2: MathJax.typesetPromise() の完了後、コンテナ内からレンダリング済みの数式要素（mjx-container要素）をすべて取得する。
    処理3: 取得した数式要素の配列と、事前に抽出したLaTeX文字列の配列を、出現順に紐付ける。
    処理4: 各数式要素にマウスホバーイベントを設定し、ホバー時にコピーボタンを動的に表示する。ボタンには、対応するLaTeX文字列をコピーする機能を割り当てる。
  - 実装上の注意:
    この方式は、MathJaxライブラリの内部実装（例: 属性の有無）に依存しないため、将来のアップデート耐性が高い。
    MathJax.typesetPromise() の完了直後にDOM操作を行うと、ブラウザの描画が間に合わない場合がある。完了後の処理は setTimeout(..., 0) 等でごく短い遅延を挟み、次の描画サイクルで実行することが望ましい。

・SVGレンダリング:
  - svg言語が指定されたコードブロックを、レンダリングされた画像として表示する。
  - 表示されたSVGラッパーには、タイトル（"SVG"）、コピーボタン、ダウンロードボタンを含むヘッダーを設ける。
  - ダウンロードするファイル名は、fig-[HHmm].svg のように、元のメッセージの送信時刻（時分）を付与する。

・コードブロックレンダリング (highlight.js):
  - svg以外の言語が指定されたコードブロックにhighlight.jsを適用する。
  - 各コードブロックには、言語名、コピーボタン、ダウンロードボタンを含むヘッダーを設ける。
  - DOM実装上の注意:
    markedライブラリが生成したpreタグとcodeタグの組を、自作のヘッダー付きコンテナで「包み込む(wrap)」方式で実装すること。生成された要素を直接 replaceWith() で置き換えようとすると、DOMの循環参照エラーが発生する可能性があるため注意する。
  - CSS実装上の注意:
    highlight.jsのテーマが適用されると、preタグ自体に背景色とpaddingが設定される。自作コンテナのスタイルと重複して二重枠に見えるのを防ぐため、コンテナの背景色はテーマの背景色に合わせ、preタグ自体の背景色は transparent に、paddingは0に上書きすること。
  - ダウンロードするファイル名は、code-[HHmm].[拡張子] のように、元のメッセージの送信時刻（時分）を付与する。拡張子は言語名から推測される標準的なもの（例: javascript -> .js）を使用する。
  - CSSで white-space: pre-wrap; word-break: break-all; を指定し、長い行の強制折り返しを行う。

3.4. 履歴データ構造 (JSON)
[
  {
    "role": "user",
    "text": "二次方程式 $ax^2 + bx + c = 0$ の解の公式を教えてください。",
    "timestamp": "2023-10-27T14:30:15.123Z"
  },
  {
    "role": "ai",
    "text": "はい、二次方程式の解の公式は以下の通りです。\n\n$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}$$\n",
    "timestamp": "2023-10-27T14:30:20.456Z"
  }
]
