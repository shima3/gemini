AIチャットアプリケーション開発仕様書

==================================================

1. 要求定義 (ユーザー要求)

1.1. プロジェクトゴール
最新の生成AIモデルを活用し、テキストだけでなく画像やファイルも扱える、高機能で直感的なチャットアプリケーションを開発する。これにより、ユーザーは情報収集、学習、プログラミング、アイデア創出など、多様な知的作業を効率的に行えるようになることを目指す。

1.2. ユーザーストーリー

開発者として、プログラミングに関する質問をし、コードスニペットを含んだ回答をシンタックスハイライト付きで受け取りたい。
研究者として、複雑な数式を含む論文の要約を依頼し、数式が正しくレンダリングされた状態で読みたい。
デザイナーとして、簡単なアイコンや図の作成をAIに指示し、SVG形式のベクター画像として即座に受け取りたい。
一般的なユーザーとして、画像やテキストファイルをAIに見せて、その内容について質問したい。
すべてのユーザーとして、過去のチャット履歴を簡単に保存し、後から読み込んで対話を再開したい。

2. 要件定義 (システム要件)

2.1. 画面構成とUIコンポーネント

- **ヘッダー:**
    - アプリケーションのタイトル。
    - 「設定」ボタン（設定エリアの表示/非表示を切り替えるトグル）。
- **設定エリア:**
    - **モデル名入力欄:** デフォルト値として `gemini-1.5-flash-latest` を設定。
    - **APIキー入力欄:** `type="password"`に設定。
    - **「適用」ボタン:** `type="submit"`に設定。submitすると、URLのパラメータとして、モデル名とAPIキーが設定され、それらをJavaScriptで読み取る。
    - **チャット履歴管理:**
        - 「履歴をダウンロード」ボタン。
        - 「履歴をアップロード」ボタン (`<input type="file">` を利用)。
- **チャット履歴エリア:**
    - ユーザーのメッセージは右側に、AIのメッセージは左側に表示される、吹き出し形式のUI。
    - 各メッセージの外側横に送信時刻（例: `14:30`）を表示する。表示は時と分だけだが、内部では年月日も記録している。
    - AIからの応答を待っている間、タイピング中であることを示すアニメーション（タイピングインジケーター）を表示。
- **メッセージ入力エリア (フッター):**
    - **ファイル添付ボタン:** クリックするとファイル選択ダイアログが開く。
    - **テキスト入力欄 (`<textarea>`):**
        - 入力内容に応じて高さが自動で伸び縮みする。
        - `Ctrl+Enter` (または `Cmd+Enter`) でメッセージを送信できる。
    - **送信ボタン:** メッセージやファイルが入力されている場合にのみクリック可能。
- **ファイルプレビューエリア:**
    - メッセージ送信前に、添付されたファイル名の一覧を表示。
    - 各ファイル名の横に「×」ボタンを付け、添付をキャンセルできるようにする。
- **通知:**
    - コードのコピー時などに「コピーしました！」といったメッセージを画面下部に短時間表示するトースト通知機能。

2.2. 機能要件
システムが提供すべき具体的な機能。

・設定管理
  - 設定の永続化: モデル名とAPIキーは、URLのクエリパラメータによって永続化する。これにより、ユーザーは設定済みのURLをブックマークすることで、次回以降の入力を省略できる。
  - 設定の適用方法:
    -- ユーザーがUIからモデル名とAPIキーを入力し、「適用」ボタンを押すと、フォームが**送信（submit）**される。
    -- このフォーム送信により、ページがリフレッシュされ、入力された値がURLのクエリパラメータとして付与される。（例: index.html?modelName=...&apiKey=...）
  - ページ読み込み時の挙動:
    -- ページが読み込まれた際、URLにmodelNameおよびapiKeyのクエリパラメータが存在する場合、その値を自動的に読み込み、設定フォームに反映させ、AIクライアントを初期化する。
    -- apiKeyはパスワード入力欄（type="password"）のため、画面上では値が見えない状態で保持する。

・チャット機能
  - テキストメッセージを送信できる。
  - テキストとファイルを同時に送信できる。
  - メッセージ入力エリアへのドラッグ＆ドロップでファイルを添付できる。
  - クリップボードの画像をメッセージにペーストすると画像ファイルが添付される。
  - メッセージ送信前に、添付ファイルの一覧を確認できるプレビューエリアを持つ。各ファイルには添付を取り消すためのキャンセルボタン（「×」ボタンなど）を設ける。

・コンテンツ表示機能
  - メッセージはMarkdownとして解釈され、見出し、リスト、引用などが適切に表示される。
  - メッセージ内のLaTeX形式の数式（$...$, $$...$$）は、数式としてレンダリングされる。
  - メッセージ内のSVGコードブロックは、レンダリングされた画像として表示される。
  - 上記以外のコードブロックは、言語に応じてシンタックスハイライトが適用される。

・チャット履歴管理機能
  - 現在のチャット履歴（メッセージ、タイムスタンプ、添付ファイル）をJSONファイルとしてダウンロードできる。
  - ファイル名は chat-history-mmdd-HHMM.json の形式とする。ここで、現在時刻の月（2桁）をmm、日（2桁）をdd、時（24時間表記・2桁）をHH、分（2桁）をMMとする。
  - ダウンロードしたJSONファイルをアップロードし、チャット履歴のメッセージ、時刻、添付ファイルを完全に復元できる。
  - 履歴の復元時は、ユーザーとAI双方の全メッセージ（添付ファイル情報を含む）に対して、後述のコンテンツレンダリングパイプライン（Markdown、数式、コードハイライト等）を適用し、表示を完全に再現すること。

・デバッグモード
  - URLでdebugModeパラメータが指定された場合、デバッグモードになる。
  - debugMode=userの場合、APIキーの入力やAIとの通信は行わず、ユーザが入力したメッセージをチャット履歴に表示する。
  - debugMode=aiの場合、APIキーの入力やAIとの通信は行わず、ユーザが入力したメッセージをAIからの応答としてチャット履歴に表示する。

2.3. 非機能要件

・ユーザーエクスペリエンス (UX)
  - ユーザーとAIのメッセージは吹き出し形式でチャット履歴に表示する。
  - ユーザーメッセージは右側、AIメッセージは左側からの吹き出しとする。
  - 添付ファイルの表示:
    -- ユーザーメッセージにファイルが添付されている場合、メッセージ本文の上部に、添付ファイルの一覧を「チップ（角丸の背景色付きラベル）」形式で表示する。
    -- 各チップには、ファイルの種類がわかるアイコン（例：画像ファイル、テキストファイルなど）とファイル名を表示する。
    -- この表示は、チャット履歴をJSONファイルから復元した場合にも完全に再現されること。
  - メッセージのコピーと時刻表示:
    -- 各メッセージ吹き出しのすぐ隣にコピーボタンと送信時刻(HH:MM形式)を常に表示する。ユーザーメッセージの場合、その左側にコピーボタンと送信時刻を表示する。AIメッセージの場合、その右側にコピーボタンと送信時刻を表示する。
    -- 要素はコピーボタンを上に、時刻を下に縦に並べる。

  - AIの応答中は、タイピング中であることが視覚的にわかるインジケーターを表示すること。

  - AIの応答完了時に、控えめな通知音を再生すること。

  - 操作のフィードバック: コードやSVG、メッセージ本文を簡単にコピーできるボタンを提供し、操作成功時には「コピーしました！」のようなメッセージを画面に短時間表示する（トースト通知）。

  - コンテンツ操作:
    -- コードやSVGは、ブロックごとにコピーボタンとダウンロードボタンを提供すること。
    -- 数式は、マウスホバーした際にのみ、その数式のLaTeXコードをコピーするためのボタンを表示すること。このボタンは、数式コンテナの表示領域をはみ出さないよう、コンテナの内側の右上隅に配置する。
    -- コンテンツの高さ制限: コードブロックやSVGブロックが縦に長くなりすぎ、チャット全体の可読性を損なうことを防ぐため、これらのブロックには適切な高さの上限（例：400px）を設定し、内容がはみ出す場合はブロック内で垂直スクロールできるようにすること。

  - 入力エリアと操作: メッセージ入力欄は、入力内容に応じて高さが自動で調整されること。Ctrl+Enter (MacではCmd+Enter) でメッセージを送信できること。
スクロール動作:
    -- メッセージ追加時: ユーザーまたはAIのメッセージがDOMに追加された直後、チャット履歴が常に最下部に自動スクロールされること。
    -- AI応答完了時: AIからの応答がすべて完了した時点で、そのAIメッセージの最上部が表示領域の上端に揃うように自動スクロールすること。
    -- 手動スクロールによる抑制: 上記の自動スクロールは、ユーザーが手動でスクロール中は実行されないこと。具体的には、スクロール位置が最下部から一定量（例: 100px）以上離れている状態を「手動スクロール中」と判定する。
    -- 自動スクロールの再開: ユーザーが新たにメッセージを送信した時点で、手動スクロール状態を解除し、自動スクロールを再度有効にすること。

・パフォーマンス
  - AIからの応答は、負荷軽減と安定性ため、ストリーミングを使わないこと。
  - ファイルの読み込みやAPI通信は非同期で行い、UIのブロッキングを避けること。

・セキュリティ
APIキー入力欄は、入力内容が見えないようにパスワード形式 (type="password") にすること。

・エラーハンドリング
  - APIキーが未設定、または無効な場合は、チャット機能を無効化し、設定エリアを表示すること。さらに、メッセージ入力欄、送信ボタン、ファイル添付ボタン、および履歴管理機能（ダウンロード、アップロード）を操作不能状態にする。
  - API通信でエラーが発生した場合、エラーメッセージをユーザーがコピー可能な形式で画面に表示し、入力内容（テキストや添付ファイル）を保持したまま再送信できるようにすること。
  - 入力内容の保持: API通信に失敗した場合、ユーザーが入力したテキストや添付ファイルは入力欄に保持されなければならない。これを確実にするため、API呼び出しが成功したことを確認した後にのみ、入力エリアと添付ファイルの状態をクリアするという処理順序を徹底すること。

・デザイン・アクセシビリティ:
  - アプリケーション全体の配色は、WCAG (Web Content Accessibility Guidelines) 2.1の達成基準AAで定められているコントラスト比（通常のテキストで4.5:1以上）を満たすこと。
  - 特に、チャットの背景色とメッセージのテキスト色のコントラストを十分に確保し、可読性を保証する。

3. 技術仕様

3.1. 開発環境・技術スタック

・基本構成: すべてのコードを単一のHTMLファイルに記述する。

・言語: HTML, CSS, Vanilla JavaScript (ES Modules形式)

・実行環境:
  - 本アプリケーションは、**Webサーバーを必要とせず**、HTMLファイルを直接ブラウザで開くことで動作する。
  - これは、利用する外部ライブラリ（`@google/generative-ai`）を、適切なCORS設定がされたCDNからES Modules形式で読み込むことで実現する。

・外部ライブラリ: 以下のライブラリは、`<head>`内で`<script>`タグを用いてCDNから同期的に読み込む。CORSポリシーの問題を回避し、ローカルファイルからの直接実行を可能にする。
  - marked, highlight.js (+テーマCSS), MathJax は、<head>内で通常の<script>タグを用いてCDNから読み込む。
  - @google/generative-ai: Google Gemini APIとの通信用は、type="module" を指定した<script>タグ内で、import文を用いて非同期に読み込む。

・技術的注釈（ライブラリ読み込みについて）:
  - `@google/generative-ai`を`import`で読み込む際、`unpkg.com`の`.mjs`ファイルを使用する。このCDNは、ブラウザのセキュリティ機能であるCORS（Cross-Origin Resource Sharing）ポリシーをクリアできるよう、適切なレスポンスヘッダー（`Access-Control-Allow-Origin: *`）を返すため、`file://`プロトコルからの直接的なモジュール読み込みが許可される。
  - 他のCDNやファイル形式（例: `.js`）を指定した場合、CORSエラーやモジュール形式の違いにより、アプリケーションが動作しない可能性があるため、必ず上記の指定URLを使用すること。

・UI実装上の注意点:
  - 設定フォームの実装:
    -- 設定フォームは<form>タグで囲み、method="GET"属性を指定すること。
    -- モデル名の<input>要素にはname="modelName"を、APIキーの<input>要素にはname="apiKey"を、それぞれname属性として指定する。これにより、フォーム送信時に値が適切なクエリパラメータとしてURLに付与される。
    -- 「適用」ボタンはtype="submit"として実装し、クリック時にフォームが送信されるようにすること。
  - JavaScriptによる処理:
    -- フォーム送信はブラウザの標準機能に任せるため、設定フォームのsubmitイベントをJavaScriptで捕捉して preventDefault() する必要はない。
    -- ページ読み込み時に、URLのクエリパラメータをJavaScriptで解析し（new URLSearchParams(window.location.search)を利用）、フォームの値を設定する処理を実装すること。
  - 他ボタンとの区別:
    -- 設定フォーム内の「履歴をダウンロード」「履歴をアップロード」ボタンなど、フォーム送信を意図しないボタンは、type="button"として実装し、ページの再読み込みを引き起こさないよう明確に区別すること。

3.2. API連携仕様 (Google Gemini API)

初期化:
GoogleGenerativeAI(apiKey)でクライアントを初期化する。
getGenerativeModel()でモデルを取得する際、以下のsystemInstructionを必ず設定する。
「ユーザーから図形やグラフの描画を指示された場合は、必ずSVGコードを生成し、そのコードブロックの言語指定を ```svg として応答してください。他の形式（xmlなど）は使用しないでください。また、数式を記述する際は、必ずLaTeX形式（インラインは$...$、ブロックは$$...$$）を使用してください。」

メッセージ送信:
  - 画像ファイルは、FileReader.readAsDataURL()でBase64にエンコードし、MIMEタイプを分離してinlineData形式のオブジェクト ({ inlineData: { data: "...", mimeType: "..." } }) として送信する。
  - テキストファイルは、FileReader.readAsText()で内容を読み込み、以下の形式のプロンプトに整形して送信する。
    [添付ファイル: {ファイル名}]\n```\n{ファイルの内容}\n```
  - 履歴の整形: APIに渡す履歴配列（history）を生成する際、過去のユーザーメッセージにファイルが添付されていた場合は、AIが文脈を理解しやすくするため、[ユーザーは過去のターンでファイル「{ファイル名}」を添付しました] のようなテキストをtextパートの先頭に追加すること。

3.3. コンテンツレンダリング仕様

・AI応答の表示方式: AIからの応答はレンダリング負荷と表示の安定性を考慮し、ストリーミングは使わず、応答完了後、後述のレンダリングパイプラインを一度に実行し、リッチコンテンツ（Markdown、数式、コードブロック等）に変換する。

1. AIからの応答に含まれる数式、SVGなどのコードを抽出し、IDに置き換える。
   IDはmarkedライブラリに変換されない文字のみからなる文字列とする。
2. IDに置き換えた後のAIからの応答をmarkedライブラリでHTMLに変換する。これをHTML応答と呼ぶ。
3. 抽出された各数式をMathJaxで変換し、HTML応答に含まれるIDと差し替える。
4. 抽出された各SVGについて、「SVG」というタイトル、コピーボタン、ダウンロードボタン、そのSVGを含むコードブロック要素を作成し、HTML応答に含まれるIDと差し替える。
5. その他の抽出された各コードについて、コードの種類を示すタイトル、コピーボタン、ダウンロードボタン、そのコードをハイライトした結果を含むコードブロック要素を作成し、HTML応答に含まれるIDと差し替える。

  - 実装上の注意:
    MathJax.typesetPromise() の完了直後にDOM操作を行うと、ブラウザの描画が間に合わない場合がある。完了後の処理は setTimeout(..., 0) を用いて次の描画サイクルで実行すること。

  - オーバーフロー対策: レンダリングされた数式（特に長いインライン数式）がメッセージの幅を超えて表示が崩れるのを防ぐこと。MathJaxが生成するコンテナ要素（mjx-container）に対して max-width: 100%; と overflow-x: auto; を適用し、はみ出した部分は水平スクロールで閲覧できるようにする。

  - コピーボタンの配置: ホバー時に表示するコピーボタンは、親コンテナ（mjx-container）の内側に配置すること。position: absolute; を使用し、top と right プロパティで右上隅からのオフセット（例: top: 2px; right: 2px;）を指定する。transform: translate(...) を用いてコンテナの外側に配置する手法は、意図しないレイアウト崩れやスクロールバーの発生原因となるため避けること。

・SVGレンダリング:
  - svg言語が指定されたコードブロックを、レンダリングされた画像として表示する。
  - 表示されたSVGラッパーには、タイトル（"SVG"）、コピーボタン、ダウンロードボタンを含むヘッダーを設ける。
  - ダウンロードするファイル名は fig-MMDD-HHmm.svg のように、元のメッセージの送信日時の月日と時分を付与する。

・コードブロックレンダリング (highlight.js):
  - svg以外の言語が指定されたコードブロックにhighlight.jsを適用する。
  - 各コードブロックには、言語名、コピーボタン、ダウンロードボタンを含むヘッダーを設ける。
  - DOM実装上の注意:
    markedライブラリが生成したpreタグとcodeタグの組を、自作のヘッダー付きコンテナで「包み込む(wrap)」方式で実装すること。生成された要素を直接 replaceWith() で置き換えようとすると、DOMの循環参照エラーが発生する可能性があるため注意する。
  - CSS実装上の注意:
    highlight.jsのテーマが適用されると、preタグ自体に背景色とpaddingが設定される。自作コンテナのスタイルと重複して二重枠に見えるのを防ぐため、コンテナの背景色はテーマの背景色に合わせ、preタグ自体の背景色は transparent に、paddingは0に上書きすること。
  - ダウンロードするファイル名は code-MMDD-HHmm.[拡張子] のように、元のメッセージの送信日時の月日と時分を付与する。拡張子は言語名から推測される標準的なもの（例: javascript -> .js）を使用する。
  - CSSで white-space: pre-wrap; word-break: break-all; を指定し、長い行の強制折り返しを行う。
  - レスポンシブ対応: 幅の狭い画面でボタンのテキストが縦書きになることを防ぐため、button要素には white-space: nowrap; と flex-shrink: 0; を適用すること。

・通知音の再生:
  - 実装方針: ブラウザの自動再生ポリシー（ユーザーの操作なしに音声を再生できない制約）を回避するため、AudioContext Web API を用いて動的に音を生成する方式を採用する。音声ファイルの読み込みは行わない。
  - 処理フロー:
    1. AudioContextのインスタンスは、ページ読み込み時ではなく、ユーザーが初めてメッセージを送信するイベントハンドラ内で生成し、resume()を呼び出して有効化する。これにより、ユーザー操作と音声再生機能の有効化が紐付けられる。
    2. AIの応答完了時に再生する通知音は、AudioContextのcreateOscillator（発振器）とcreateGain（音量制御）を用いて生成する。
    3. 音の仕様は、耳障りでない440Hz〜880Hz程度の正弦波（sine）を、約0.2秒程度の短いフェードアウトで再生するものとする。

3.4. 履歴データ構造 (JSON)
チャット履歴は、メッセージオブジェクトの配列として表現する。ユーザーメッセージには、添付ファイル情報を保持するための files 配列をオプションとして含めることができる。
files 配列の各要素は、ファイル名(name)、MIMEタイプ(type)、およびBase64エンコードされたコンテンツまたはプレーンテキストコンテンツ(content)を含むオブジェクトとする。

[
  {
    "role": "user",
    "text": "この画像について説明してください。",
    "timestamp": "2023-10-28T10:00:05.123Z",
    "files": [
      {
        "name": "cat-on-a-laptop.jpg",
        "type": "image/jpeg",
        "content": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD..."
      }
    ]
  },
  {
    "role": "model",
    "text": "はい、これはラップトップキーボードの上でくつろいでいる猫の画像です。",
    "timestamp": "2023-10-28T10:00:10.456Z"
  },
  {
    "role": "user",
    "text": "二次方程式 $ax^2 + bx + c = 0$ の解の公式を教えてください。",
    "timestamp": "2023-10-28T10:01:15.987Z"
  },
  {
    "role": "model",
    "text": "はい、二次方程式の解の公式は以下の通りです。\n\n$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}$$\n",
    "timestamp": "2023-10-28T10:01:20.789Z"
  }
]

3.5. アプリケーションのライフサイクル (Application Lifecycle)

本アプリケーションは、以下の順序で初期化処理を行うこと。

1.  **DOMコンテンツの読み込み完了**: JavaScriptの実行は、`DOMContentLoaded`イベントの発火後まで待機する。
2.  **DOM要素のキャッシュ**: アプリケーション全体で使用するDOM要素（ボタン、入力欄など）への参照を、この段階で一度に取得し、変数に保持する。
3.  **イベントリスナーの設定**: キャッシュしたDOM要素に対して、クリックや入力などのイベントリスナーを全て設定する。
4.  **設定の読み込みと適用**: URLのクエリパラメータを解析し、モデル名とAPIキーを取得する。
5.  **APIクライアントの初期化**: APIキーが存在する場合、Gemini APIクライアントの初期化を試みる。
6.  **UI状態の更新**: APIクライアントの初期化成否に基づき、メッセージ入力欄や各種ボタンの有効/無効状態を決定する。
